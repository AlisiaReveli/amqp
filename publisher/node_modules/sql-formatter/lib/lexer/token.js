"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testToken = exports.isToken = exports.isReserved = exports.isParameter = exports.TokenType = exports.EOF_TOKEN = void 0;

/** Token type enum for all possible Token categories */
var TokenType;
/** Struct to store the most basic cohesive unit of language grammar */

exports.TokenType = TokenType;

(function (TokenType) {
  TokenType["QUOTED_IDENTIFIER"] = "QUOTED_IDENTIFIER";
  TokenType["IDENTIFIER"] = "IDENTIFIER";
  TokenType["STRING"] = "STRING";
  TokenType["VARIABLE"] = "VARIABLE";
  TokenType["RESERVED_KEYWORD"] = "RESERVED_KEYWORD";
  TokenType["RESERVED_FUNCTION_NAME"] = "RESERVED_FUNCTION_NAME";
  TokenType["RESERVED_LOGICAL_OPERATOR"] = "RESERVED_LOGICAL_OPERATOR";
  TokenType["RESERVED_PHRASE"] = "RESERVED_PHRASE";
  TokenType["RESERVED_DEPENDENT_CLAUSE"] = "RESERVED_DEPENDENT_CLAUSE";
  TokenType["RESERVED_SET_OPERATION"] = "RESERVED_SET_OPERATION";
  TokenType["RESERVED_COMMAND"] = "RESERVED_COMMAND";
  TokenType["RESERVED_JOIN"] = "RESERVED_JOIN";
  TokenType["RESERVED_CASE_START"] = "RESERVED_CASE_START";
  TokenType["RESERVED_CASE_END"] = "RESERVED_CASE_END";
  TokenType["OPERATOR"] = "OPERATOR";
  TokenType["COMMA"] = "COMMA";
  TokenType["OPEN_PAREN"] = "OPEN_PAREN";
  TokenType["CLOSE_PAREN"] = "CLOSE_PAREN";
  TokenType["LINE_COMMENT"] = "LINE_COMMENT";
  TokenType["BLOCK_COMMENT"] = "BLOCK_COMMENT";
  TokenType["NUMBER"] = "NUMBER";
  TokenType["NAMED_PARAMETER"] = "NAMED_PARAMETER";
  TokenType["QUOTED_PARAMETER"] = "QUOTED_PARAMETER";
  TokenType["NUMBERED_PARAMETER"] = "NUMBERED_PARAMETER";
  TokenType["POSITIONAL_PARAMETER"] = "POSITIONAL_PARAMETER";
  TokenType["DELIMITER"] = "DELIMITER";
  TokenType["EOF"] = "EOF";
})(TokenType || (exports.TokenType = TokenType = {}));

/**
 * For use as a "missing token"
 * e.g. in lookAhead and lookBehind to avoid dealing with null values
 */
var EOF_TOKEN = {
  type: TokenType.EOF,
  raw: '«EOF»',
  text: '«EOF»',
  start: Infinity,
  end: Infinity
};
/** Checks if two tokens are equivalent */

exports.EOF_TOKEN = EOF_TOKEN;

var testToken = function testToken(compareToken) {
  return function (token) {
    return token.type === compareToken.type && token.text === compareToken.text;
  };
};
/** Util object that allows for easy checking of Reserved Keywords */


exports.testToken = testToken;
var isToken = {
  AS: testToken({
    text: 'AS',
    type: TokenType.RESERVED_KEYWORD
  }),
  AND: testToken({
    text: 'AND',
    type: TokenType.RESERVED_LOGICAL_OPERATOR
  }),
  ARRAY: testToken({
    text: 'ARRAY',
    type: TokenType.RESERVED_KEYWORD
  }),
  BETWEEN: testToken({
    text: 'BETWEEN',
    type: TokenType.RESERVED_KEYWORD
  }),
  CASE: testToken({
    text: 'CASE',
    type: TokenType.RESERVED_CASE_START
  }),
  CAST: testToken({
    text: 'CAST',
    type: TokenType.RESERVED_FUNCTION_NAME
  }),
  BY: testToken({
    text: 'BY',
    type: TokenType.RESERVED_KEYWORD
  }),
  END: testToken({
    text: 'END',
    type: TokenType.RESERVED_CASE_END
  }),
  FROM: testToken({
    text: 'FROM',
    type: TokenType.RESERVED_COMMAND
  }),
  LIMIT: testToken({
    text: 'LIMIT',
    type: TokenType.RESERVED_COMMAND
  }),
  SELECT: function SELECT(token) {
    return /^SELECT\b/.test(token.text) && token.type === TokenType.RESERVED_COMMAND;
  },
  SET: testToken({
    text: 'SET',
    type: TokenType.RESERVED_COMMAND
  }),
  STRUCT: testToken({
    text: 'STRUCT',
    type: TokenType.RESERVED_KEYWORD
  }),
  TABLE: testToken({
    text: 'TABLE',
    type: TokenType.RESERVED_KEYWORD
  }),
  WINDOW: testToken({
    text: 'WINDOW',
    type: TokenType.RESERVED_COMMAND
  }),
  WITH: testToken({
    text: 'WITH',
    type: TokenType.RESERVED_COMMAND
  })
};
/** Checks if token is any Reserved Keyword or Command */

exports.isToken = isToken;

var isReserved = function isReserved(token) {
  return token.type === TokenType.RESERVED_KEYWORD || token.type === TokenType.RESERVED_FUNCTION_NAME || token.type === TokenType.RESERVED_LOGICAL_OPERATOR || token.type === TokenType.RESERVED_PHRASE || token.type === TokenType.RESERVED_DEPENDENT_CLAUSE || token.type === TokenType.RESERVED_COMMAND || token.type === TokenType.RESERVED_SET_OPERATION || token.type === TokenType.RESERVED_JOIN || token.type === TokenType.RESERVED_CASE_START || token.type === TokenType.RESERVED_CASE_END;
};
/** checks if token is one of the parameter tokens */


exports.isReserved = isReserved;

var isParameter = function isParameter(token) {
  return token.type === TokenType.NUMBERED_PARAMETER || token.type === TokenType.NAMED_PARAMETER || token.type === TokenType.POSITIONAL_PARAMETER || token.type === TokenType.QUOTED_PARAMETER;
};

exports.isParameter = isParameter;
//# sourceMappingURL=token.js.map