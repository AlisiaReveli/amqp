"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertPerformanceDateTime = exports.isConvertibleToString = exports.unzipAsync = exports.zipAsync = exports.stringify = exports.stringArrayToMd5 = void 0;
const crypto_1 = __importDefault(require("crypto"));
const zlib_1 = __importDefault(require("zlib"));
const moment_1 = __importDefault(require("moment"));
require("moment-timezone");
function stringArrayToMd5(values) {
    return crypto_1.default.createHash('md5').update(values.join('|')).digest('hex');
}
exports.stringArrayToMd5 = stringArrayToMd5;
function stringify(value) {
    if (!value) {
        return '';
    }
    if (typeof value === 'object') {
        if ('toString' in value &&
            typeof value['toString'] === 'function') {
            return value.toString();
        }
        return '';
    }
    if (typeof value === 'number') {
        return value.toString();
    }
    if (typeof value === 'string') {
        return value;
    }
    return String(value);
}
exports.stringify = stringify;
async function zipAsync(value) {
    return new Promise((resolve, reject) => {
        zlib_1.default.gzip(value, (err, value) => {
            if (err) {
                reject(err);
            }
            resolve(value);
        });
    });
}
exports.zipAsync = zipAsync;
async function unzipAsync(value) {
    return new Promise((resolve, reject) => {
        zlib_1.default.unzip(value, (err, value) => {
            if (err) {
                reject(err);
            }
            resolve(value);
        });
    });
}
exports.unzipAsync = unzipAsync;
function isConvertibleToString(value) {
    return (!!value &&
        typeof value === 'object' &&
        typeof value.toString === 'function');
}
exports.isConvertibleToString = isConvertibleToString;
/*
 * If it's a performance model we will insert the date
 * according to the timezone of the user
 * (so the date on the database does not represent the UTC date
 * but the current statistics date of the inserted entities)
 *
 * If the date is not the current date (but yesterday before yesterday etc.)
 * We will insert it at 23:59:59 of that particular day, so it's the last record of that day
 * */
function convertPerformanceDateTime(value, context) {
    const fn = function (dt, timezone) {
        const currentServerDate = moment_1.default.tz(timezone);
        const date = (0, moment_1.default)(dt);
        let final_date = currentServerDate;
        const diff = (0, moment_1.default)(currentServerDate)
            .startOf('day')
            .diff((0, moment_1.default)(date).startOf('day'), 'days');
        if (diff > 0) {
            final_date = (0, moment_1.default)(date).endOf('day');
        }
        return final_date.format('YYYY-MM-DD HH:mm:ss');
    };
    const date = value;
    const timezone = context['timezone'];
    if (!date) {
        throw new Error('Date is required!');
    }
    if (!timezone) {
        throw new Error('Timezone is required!');
    }
    return fn(date, timezone);
}
exports.convertPerformanceDateTime = convertPerformanceDateTime;
//# sourceMappingURL=helpers.js.map