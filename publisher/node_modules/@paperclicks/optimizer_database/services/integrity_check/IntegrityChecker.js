"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IntegrityChecker = void 0;
const ModelSchemaCollection_1 = require("../../core/schema/model/schema/ModelSchemaCollection");
const TableFieldConflict_1 = require("./TableFieldConflict");
const ModelFieldConflict_1 = require("./ModelFieldConflict");
class IntegrityChecker {
    constructor(model) {
        this.model = model;
    }
    get schema() {
        return ModelSchemaCollection_1.AllModelSchemas.getModel(this.model);
    }
    baseSchema(model = this.model) {
        const proto = Object.getPrototypeOf(model);
        if (proto && proto.name && proto.name !== '') {
            return ModelSchemaCollection_1.AllModelSchemas.getModel(proto);
        }
        return null;
    }
    fieldConflictsWithSchema(other) {
        var _a;
        const ownFieldSet = new Set(this.schema.fields.map((x) => x.name));
        const otherFields = new Set(other.fields.map((x) => x.name));
        const ownBaseSchema = this.baseSchema();
        /*
        * Ignore base schema fields
        *  */
        const baseSchemasFields = new Set([
            ...(((_a = ownBaseSchema === null || ownBaseSchema === void 0 ? void 0 : ownBaseSchema.fields) === null || _a === void 0 ? void 0 : _a.map((x) => x.name)) || []),
        ]);
        const returnValue = new Array();
        for (const item of ownFieldSet) {
            if (otherFields.has(item) && !baseSchemasFields.has(item)) {
                returnValue.push(new ModelFieldConflict_1.ModelFieldConflict(this.schema.modelConstructor.name, item, other.modelConstructor.name, item));
            }
        }
        return returnValue;
    }
    tableConflictsWithItself() {
        const allTableFields = {};
        for (const schemaField of this.schema.fields) {
            const tableFields = schemaField.tableFields;
            for (const tableField of tableFields) {
                const tableName = tableField.table.tableConstructor.name;
                const tableKey = `${tableName}.${tableField.name}`;
                allTableFields[tableKey] =
                    allTableFields[tableKey] || new Set();
                allTableFields[tableKey].add(schemaField.name);
            }
        }
        const returnValue = [];
        for (const [tableInfo, schemaFieldSet] of Object.entries(allTableFields)) {
            const fieldSet = Array.from(schemaFieldSet);
            if (fieldSet.length > 1) {
                const [tableName, tableField] = tableInfo.split('.');
                returnValue.push(new TableFieldConflict_1.TableFieldConflict(this.schema.modelConstructor.name, tableName, tableField, fieldSet));
            }
        }
        return returnValue;
    }
}
exports.IntegrityChecker = IntegrityChecker;
//# sourceMappingURL=IntegrityChecker.js.map