"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TrafficSourcePerformanceChecker = exports.TrackerPerformanceChecker = exports.EntityPerformanceChecker = exports.EntityModelChecker = void 0;
const IntegrityChecker_1 = require("./IntegrityChecker");
const entities_1 = require("../../models/entities");
const ModelSchemaCollection_1 = require("../../core/schema/model/schema/ModelSchemaCollection");
const entities_performance_1 = require("../../models/entities_performance");
const traffic_source_performance_1 = require("../../models/traffic_source_performance");
const tracker_performance_1 = require("../../models/tracker_performance");
// foreach entity model
//		check for table field conflicts within itself
class EntityModelChecker extends IntegrityChecker_1.IntegrityChecker {
    constructor(model) {
        super(model);
    }
    checkIntegrity() {
        const tableConflicts = this.tableConflictsWithItself();
        if (tableConflicts.length) {
            const message = tableConflicts.map((x) => x.toString()).join('\n');
            throw new Error(message);
        }
    }
}
exports.EntityModelChecker = EntityModelChecker;
// foreach entity performance model
//		check for table field conflicts within itself
class EntityPerformanceChecker extends IntegrityChecker_1.IntegrityChecker {
    constructor(model) {
        super(model);
    }
    checkIntegrity() {
        const tableConflicts = this.tableConflictsWithItself();
        if (tableConflicts.length) {
            const message = tableConflicts.map((x) => x.toString()).join('\n');
            throw new Error(message);
        }
    }
}
exports.EntityPerformanceChecker = EntityPerformanceChecker;
// foreach tracker performance model
//		check for table field conflicts within itself
//		foreach model field of the model
//			check for model field names conflict with all the entities models
//			check for model field names conflict with all the entities performance models
//			check for model field names conflict with all the other tracker performance models
//			check for model field names conflict with all the traffic source performance models
class TrackerPerformanceChecker extends IntegrityChecker_1.IntegrityChecker {
    constructor(model) {
        super(model);
    }
    checkIntegrity() {
        const tableConflicts = this.tableConflictsWithItself();
        const fieldConflicts = new Array();
        for (const entity of Object.values(entities_1.EntitiesModels)) {
            fieldConflicts.push(...this.fieldConflictsWithSchema(ModelSchemaCollection_1.AllModelSchemas.getModel(entity)));
        }
        for (const entityPerformance of Object.values(entities_performance_1.EntitiesPerformanceModels)) {
            fieldConflicts.push(...this.fieldConflictsWithSchema(ModelSchemaCollection_1.AllModelSchemas.getModel(entityPerformance)));
        }
        for (const trafficSourcePerformance of Object.values(traffic_source_performance_1.TrafficSourcePerformanceModels)) {
            fieldConflicts.push(...this.fieldConflictsWithSchema(ModelSchemaCollection_1.AllModelSchemas.getModel(trafficSourcePerformance)));
        }
        for (const trackerPerformance of Object.values(tracker_performance_1.TrackerPerformanceModels)) {
            if (trackerPerformance != this.model) {
                fieldConflicts.push(...this.fieldConflictsWithSchema(ModelSchemaCollection_1.AllModelSchemas.getModel(trackerPerformance)));
            }
        }
        const allConflicts = [
            ...tableConflicts.map((x) => x.toString()),
            ...fieldConflicts.map((x) => x.toString()),
        ];
        if (allConflicts.length > 0) {
            throw new Error(allConflicts.join('\n'));
        }
    }
}
exports.TrackerPerformanceChecker = TrackerPerformanceChecker;
// foreach traffic source performance model
//		check for table field conflicts with itself
//		foreach model field of the model
//			check for model field names conflict with all the entities models
//			check for model field names conflict with all the entities performance models
//			check for model field names conflict with all the other tracker performance models
//			check for model field names conflict with all the traffic source performance models
class TrafficSourcePerformanceChecker extends IntegrityChecker_1.IntegrityChecker {
    constructor(model) {
        super(model);
    }
    checkIntegrity() {
        const tableConflicts = this.tableConflictsWithItself();
        const fieldConflicts = new Array();
        for (const entity of Object.values(entities_1.EntitiesModels)) {
            fieldConflicts.push(...this.fieldConflictsWithSchema(ModelSchemaCollection_1.AllModelSchemas.getModel(entity)));
        }
        for (const entityPerformance of Object.values(entities_performance_1.EntitiesPerformanceModels)) {
            fieldConflicts.push(...this.fieldConflictsWithSchema(ModelSchemaCollection_1.AllModelSchemas.getModel(entityPerformance)));
        }
        for (const trafficSourcePerformance of Object.values(traffic_source_performance_1.TrafficSourcePerformanceModels)) {
            if (trafficSourcePerformance !=
                this.model) {
                fieldConflicts.push(...this.fieldConflictsWithSchema(ModelSchemaCollection_1.AllModelSchemas.getModel(trafficSourcePerformance)));
            }
        }
        for (const trackerPerformance of Object.values(tracker_performance_1.TrackerPerformanceModels)) {
            fieldConflicts.push(...this.fieldConflictsWithSchema(ModelSchemaCollection_1.AllModelSchemas.getModel(trackerPerformance)));
        }
        const allConflicts = [
            ...tableConflicts.map((x) => x.toString()),
            ...fieldConflicts.map((x) => x.toString()),
        ];
        if (allConflicts.length > 0) {
            throw new Error(allConflicts.join('\n'));
        }
    }
}
exports.TrafficSourcePerformanceChecker = TrafficSourcePerformanceChecker;
//# sourceMappingURL=model_checkers.js.map