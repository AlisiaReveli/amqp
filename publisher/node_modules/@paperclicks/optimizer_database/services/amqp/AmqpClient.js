"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AmqpClient = void 0;
const uuid_1 = require("uuid");
const helpers_1 = require("../../utils/helpers");
const JSON_HEADER = 'json';
const GZIP_ENCODING = 'gzip';
const CONTENT_ENCODING_HEADER = 'Content-Encoding';
const RPC_PREFIX = 'rpc';
class AmqpClient {
    constructor(clientOptions, connection) {
        this.clientOptions = clientOptions;
        this.connection = connection;
        this.rpcCallbacks = {};
    }
    async getPayload(r) {
        const headers = r.properties.headers || {};
        const isJson = !!headers[JSON_HEADER];
        const isGzip = headers[CONTENT_ENCODING_HEADER] === GZIP_ENCODING;
        const messageBytes = r.content;
        let messageString = r.content.toString();
        if (isGzip) {
            const unzippedBytes = await (0, helpers_1.unzipAsync)(messageBytes);
            messageString = unzippedBytes.toString();
        }
        if (isJson) {
            return JSON.parse(messageString);
        }
        return messageString;
    }
    async convertPayload(payload, requestHeaders) {
        const isJson = !!requestHeaders[JSON_HEADER] ||
            (!!payload && typeof payload === 'object');
        if (isJson && !requestHeaders[JSON_HEADER]) {
            requestHeaders[JSON_HEADER] = true;
        }
        const isGzip = requestHeaders[CONTENT_ENCODING_HEADER] === GZIP_ENCODING;
        let payloadString = '';
        if (isJson) {
            payloadString = JSON.stringify(payload);
        }
        else {
            if ((0, helpers_1.isConvertibleToString)(payload)) {
                payloadString = payload.toString();
            }
            else {
                payloadString = JSON.stringify(payload);
            }
        }
        if (isGzip) {
            const gzipBytes = await (0, helpers_1.zipAsync)(payloadString);
            return gzipBytes;
        }
        return Buffer.from(payloadString);
    }
    /**
     * Return full rpcQueue name
     */
    get baseRpcQueue() {
        if (this.clientOptions.unique) {
            if (!this.uniqueId) {
                this.uniqueId = (0, uuid_1.v4)();
            }
            /**
             * Default queue name + uuid4
             */
            return `${this.clientOptions.rpcQueue || RPC_PREFIX}.${this.uniqueId}`;
        }
        /**
         * If not unique, return simple rpc
         */
        return this.clientOptions.rpcQueue || RPC_PREFIX;
    }
    async init() {
        if (this.clientOptions.newChannel || !this.connection.channel) {
            this.channel =
                await this.connection.connection.createConfirmChannel();
        }
        else {
            this.channel = this.connection.channel;
        }
        const defaultQueueOptions = {
            durable: false,
            autoDelete: true,
        };
        const queueOptions = {
            ...defaultQueueOptions,
            ...(this.clientOptions.rpcQueueOptions || {}),
        };
        await this.channel.assertQueue(this.baseRpcQueue, queueOptions);
        await this.channel.consume(this.baseRpcQueue, (msg) => {
            this.consumeRpcMessage(msg);
        });
        console.log('AMQP Client Started');
    }
    /**
     * Handle if received a message on the default RPC queue
     * @param msg
     */
    consumeRpcMessage(msg) {
        if (!msg) {
            return;
        }
        if (msg.properties.correlationId) {
            const correlationId = msg.properties.correlationId;
            /**
             * Check if callback exists
             */
            if (this.rpcCallbacks[correlationId]) {
                try {
                    /**
                     * Check message headers for error
                     */
                    if (msg.properties.headers.error) {
                        // Return error
                        this.rpcCallbacks[correlationId](this.getPayload(msg));
                    }
                    else {
                        /**
                         * Return success
                         */
                        this.rpcCallbacks[correlationId](null, this.getPayload(msg));
                    }
                }
                catch (err) {
                    /**
                     * Catch if any other exception is thrown during parsing
                     */
                    this.rpcCallbacks[correlationId](err);
                }
                /**
                 * Acknowledge message if handled
                 */
                this.channel.ack(msg);
                /**
                 * Delete the callback after is handled
                 */
                delete this.rpcCallbacks[correlationId];
            }
            else {
                /**
                 * Acknowledge message if the callback to handle it is removed
                 */
                if (this.clientOptions.unique) {
                    this.channel.ack(msg);
                }
                else {
                    /**
                     * Requeue message if not handled and the queue is not unique
                     */
                    this.channel.nack(msg, false, true);
                }
            }
        }
        else {
            /**
             * Acknowledge message if it doesn't have correlation id
             */
            this.channel.ack(msg);
        }
    }
    /**
     * RPC requests, publishes message on the given queue and waits for a response on the default RPC queue
     * @param exchange
     * @param routingKey
     * @param payload
     * @param options
     */
    async rpc(exchange, routingKey, payload, options) {
        const correlationId = (0, uuid_1.v4)();
        return new Promise(async (resolve, reject) => {
            /**
             * Callback to register on rpc reply or timeout error
             * @param err
             * @param payload
             */
            // this.rpcCallbacks[correlationId] = (
            const fn = (err, payload) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(payload);
                }
            };
            this.rpcCallbacks[correlationId] =
                fn;
            // const timeout = options!.
            let timeout = 10 * 60 * 1000;
            if (options && options.expiration) {
                timeout = options.expiration;
            }
            /**
             * After called check if the callback still exists and reject it with the timeout message
             */
            setTimeout(() => {
                if (this.rpcCallbacks[correlationId]) {
                    this.rpcCallbacks[correlationId](new Error('RPC TIMEOUT'));
                    delete this.rpcCallbacks[correlationId];
                }
            }, timeout);
            /**
             * Send message and wait for reply
             */
            await this.publish(exchange, routingKey, payload, {
                ...(options || {}),
                replyTo: this.baseRpcQueue,
                correlationId: correlationId,
            });
        });
    }
    /**
     * Send message directly to the specified queue
     * @param queue
     * @param payload
     * @param options
     */
    async sendToQueue(queue, payload, options) {
        options = options || {};
        options.headers = options.headers || {};
        const bytes = await this.convertPayload(payload, options.headers);
        await new Promise((resolve, reject) => {
            this.channel.sendToQueue(queue, bytes, options, (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    }
    /**
     * Publish message to an exchange
     * @param exchange
     * @param payload
     * @param routingKey
     * @param options
     */
    async publish(exchange, routingKey = '', payload, options = undefined) {
        options = options || {};
        options.headers = options.headers || {};
        const bytes = await this.convertPayload(payload, options.headers);
        await new Promise((resolve, reject) => {
            this.channel.publish(exchange, routingKey, bytes, options, (err) => {
                if (err) {
                    reject(err);
                }
                resolve();
            });
        });
    }
    async close() {
        var _a;
        await ((_a = this.channel) === null || _a === void 0 ? void 0 : _a.close());
        await this.connection.connection.close();
    }
}
exports.AmqpClient = AmqpClient;
//# sourceMappingURL=AmqpClient.js.map