"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InsertQueryBuilder = void 0;
const InsertQuery_1 = require("./InsertQuery");
const ModelSchemaCollection_1 = require("../schema/model/schema/ModelSchemaCollection");
/**
 * Use this insert query builder to generate {@link InsertQuery} items for each table
 * Usage: new InsertQueryBuilder(Model).setData([]).getQueries()
 * @export
 * @class InsertQueryBuilder
 * @template T
 */
class InsertQueryBuilder {
    /**
     * Creates an instance of InsertQueryBuilder.
     * @param {ObjectType<T>} model
     * @memberof InsertQueryBuilder
     */
    constructor(model) {
        this._tableData = new Map();
        this._modelSchema = ModelSchemaCollection_1.AllModelSchemas.getModel(model);
    }
    /**
     * Build the local map of Tables keeping an array of dictionaries
     * for each row to be inserted at each particular table
     *
     * @param {T[]} data
     * @returns  {this}
     * @memberof InsertQueryBuilder
     */
    setData(data) {
        for (const item of data) {
            const itemMap = this.getModelFieldValues(item);
            for (const [table, entry] of itemMap.entries()) {
                const tableEntryInstance = new table.tableConstructor();
                Object.assign(tableEntryInstance, entry);
                if (tableEntryInstance.isValid()) {
                    const current = this._tableData.get(table) || [];
                    current.push(entry);
                    this._tableData.set(table, current);
                }
            }
        }
        return this;
    }
    /**
     * Build queries that encapsulate the items that should be inserted in the database
     *
     * @returns  {GoInsertQuery[]}
     * @memberof InsertQueryBuilder
     */
    getQueries() {
        const queries = [];
        for (const [table, data] of this._tableData.entries()) {
            queries.push(new InsertQuery_1.GoInsertQuery(table, data));
        }
        return queries;
    }
    /**
     * For a single item generate a map using Tables as a key and a dict
     * as its value to insert
     *
     * @private
     * @param {T} data
     * @returns  {Map<TableSchema, Record<string, unknown>>}
     * @memberof InsertQueryBuilder
     */
    getModelFieldValues(data) {
        /**
         * Start by getting the values for each table field
         * (Table fields might be children of different tables)
         **/
        const dataRecord = data;
        const tableFieldMap = new Map();
        for (const field of this._modelSchema.fields) {
            const fieldValue = field.getValue(dataRecord);
            for (const tableField of field.tableFields) {
                const tableValue = tableField.transformValue(fieldValue);
                tableFieldMap.set(tableField, tableValue);
            }
        }
        /*
         * Group values by table
         */
        const returnValue = new Map();
        for (const [tableSchemaField, value] of tableFieldMap.entries()) {
            const currentTableValue = returnValue.get(tableSchemaField.table) || {};
            currentTableValue[tableSchemaField.name] = value;
            returnValue.set(tableSchemaField.table, currentTableValue);
        }
        return returnValue;
    }
}
exports.InsertQueryBuilder = InsertQueryBuilder;
//# sourceMappingURL=InsertQueryBuilder.js.map