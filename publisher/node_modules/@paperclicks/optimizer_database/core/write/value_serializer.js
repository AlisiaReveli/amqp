"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeValue = void 0;
const moment_1 = __importDefault(require("moment"));
const helpers_1 = require("../../utils/helpers");
const valuesConverters = new Map([
    [
        /^UInt8/,
        (value, _type, _regex) => {
            return !!value;
        },
    ],
    [
        /^U?Int(\d+)/,
        (value, _type, _regex) => {
            if (typeof value === 'boolean') {
                return Number(value);
            }
            if (!value || Number.isNaN(Number(value))) {
                return 0;
            }
            return Math.floor(Number(value));
        },
    ],
    [
        /^Float(\d+)/,
        (value, _type, _regex) => {
            if (value === null) {
                return -1;
            }
            if (Number.isNaN(Number(value))) {
                return 0;
            }
            return Number(value);
        },
    ],
    [
        /^DateTime/,
        (value, _type, _regex) => {
            if (value) {
                try {
                    return `${(0, moment_1.default)(value).format('YYYY-MM-DD HH:mm:ss')}`;
                }
                catch (ignore) {
                    //
                }
            }
            return (0, moment_1.default)().format('YYYY-MM-DD HH:mm:ss');
        },
    ],
    [
        /^Date/,
        (value, _type, _regex) => {
            if (value) {
                try {
                    return (0, moment_1.default)(value).format('YYYY-MM-DD');
                }
                catch (ignore) {
                    //
                }
            }
            return (0, moment_1.default)().format('YYYY-MM-DD');
        },
    ],
    [
        /^String/,
        (value, _type, _regex) => {
            if (typeof value === 'number') {
                return String(value);
            }
            if (!value) {
                return '-';
            }
            if (typeof value === 'string') {
                return value;
            }
            if (typeof value === 'object') {
                return JSON.stringify(value);
            }
            if ((0, helpers_1.isConvertibleToString)(value)) {
                return value.toString();
            }
            return '';
        },
    ],
    [
        /^Array\((?<inner>.*)\)/,
        (value, type, regex) => {
            var _a, _b;
            if (Array.isArray(value)) {
                const inner = (_b = (_a = regex.exec(type)) === null || _a === void 0 ? void 0 : _a.groups) === null || _b === void 0 ? void 0 : _b.inner;
                if (inner) {
                    return value.map((x) => serializeValue(inner, x));
                }
            }
            return [];
        },
    ],
    [
        /^LowCardinality\((?<inner>)\)/,
        (value, _type, _regex) => {
            if (value &&
                (typeof value === 'string' ||
                    typeof value === 'number' ||
                    typeof value === 'boolean')) {
                return serializeValue('String', value);
            }
            return '';
        },
    ],
    [
        /^FixedString\((?<inner>.*)\)/,
        (value, _type, _regex) => {
            return serializeValue('String', value);
        },
    ],
    [
        /^Nullable\((?<inner>.*)\)/,
        (value, type, regex) => {
            var _a, _b;
            const inner = (_b = (_a = regex.exec(type)) === null || _a === void 0 ? void 0 : _a.groups) === null || _b === void 0 ? void 0 : _b.inner;
            if (inner) {
                if (value) {
                    return serializeValue(inner, value);
                }
            }
            return null;
        },
    ],
]);
function serializeValue(type, value) {
    const matchedPair = Array.from(valuesConverters.entries()).find(([rgx]) => {
        return rgx.test(type);
    });
    if (matchedPair) {
        const [rgx, fn] = matchedPair;
        return fn(value, type, rgx);
    }
    throw new Error(`Unsupported type: ${type}`);
}
exports.serializeValue = serializeValue;
//# sourceMappingURL=value_serializer.js.map