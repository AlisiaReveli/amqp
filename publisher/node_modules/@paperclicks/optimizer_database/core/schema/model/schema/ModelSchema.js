"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModelSchema = void 0;
const ModelSchemaField_1 = require("./ModelSchemaField");
const ModelSchemaCollection_1 = require("./ModelSchemaCollection");
class ModelSchema {
    constructor(modelConstructor) {
        this.modelConstructor = modelConstructor;
        this.fieldsMap = {};
        this.trafficSourceTypes = [];
    }
    get baseClass() {
        const proto = Object.getPrototypeOf(this.modelConstructor);
        if (proto && proto.name && proto.name !== '')
            return proto;
        return;
    }
    get baseModelSchema() {
        const base = this.baseClass;
        if (base) {
            return ModelSchemaCollection_1.AllModelSchemas.getModel(base);
        }
    }
    get fields() {
        var _a;
        return [
            ...(((_a = this.baseModelSchema) === null || _a === void 0 ? void 0 : _a.fields) || []),
            ...Object.values(this.fieldsMap),
        ];
    }
    addField(name) {
        if (!this.hasOwnField(name)) {
            this.fieldsMap[name] = new ModelSchemaField_1.ModelSchemaField(name, this);
        }
    }
    /**
     * Return true only if this model (not its base class) has the field
     * If we need to override a field this becomes helpful because it redefines the field
     *
     * @param {string} name
     * @returns  {boolean}
     * @memberof ModelSchema
     */
    hasOwnField(name) {
        return name in this.fieldsMap;
    }
    /**
     * Register field as auto filed
     * (when model is evaluated this field is generated by piping the field values
     * with `${field1}|${field2}` and processing the md5 of the pipe result)
     *
     * @param {string} name
     * @param {string[]} fields
     * @memberof ModelSchema
     */
    addAutoField(name, fields) {
        if (this.hasOwnField(name)) {
            this.fieldsMap[name] = ModelSchemaField_1.SchemaAutoField.fromExistingField(this.fieldsMap[name], fields);
        }
        else {
            this.fieldsMap[name] = new ModelSchemaField_1.SchemaAutoField(name, this, fields);
        }
    }
    /**
     * Return or create the field
     * If the field exists on the base class (and its decorated) it returns the base class field
     * otherwise it created the field on this class
     *
     * @param {string} name
     * @returns  {ModelSchemaField}
     * @memberof ModelSchema
     */
    getField(name) {
        var _a;
        const current = this.fieldsMap[name] || ((_a = this.baseModelSchema) === null || _a === void 0 ? void 0 : _a.fieldsMap[name]);
        if (!current) {
            this.fieldsMap[name] = new ModelSchemaField_1.ModelSchemaField(name, this);
            return this.fieldsMap[name];
        }
        return current;
    }
    /**
     * Register a relation with the performance models
     *
     * @template TLeft
     * @template TRight
     * @param {ModelSchema} schema
     * @param {ModelJoinField<TLeft, TRight>[]} fields
     * @memberof ModelSchema
     */
    addJoinModel(schema, fields) {
        if (schema !== this) {
            if (!this.joinWithModels) {
                this.joinWithModels = new Map();
            }
            this.joinWithModels.set(schema, fields);
        }
    }
    /**
     * Return relations with the performance models
     *
     * @readonly
     * @type {Array<ModelJoin>}
     * @memberof ModelSchema
     */
    get joinModels() {
        if (this.joinWithModels) {
            return Array.from(this.joinWithModels.entries()).map(([schema, fields]) => {
                return { fields, schema };
            });
        }
        return [];
    }
    /**
     * Add traffic source types that this model works with
     *
     * @param {string[]} types
     * @memberof ModelSchema
     */
    addTrafficSourceTypes(types) {
        this.trafficSourceTypes.push(...types);
    }
}
exports.ModelSchema = ModelSchema;
//# sourceMappingURL=ModelSchema.js.map