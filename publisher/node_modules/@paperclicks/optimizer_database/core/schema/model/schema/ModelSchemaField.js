"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaAutoField = exports.ModelSchemaField = void 0;
const helpers_1 = require("../../../../utils/helpers");
class ModelSchemaField {
    constructor(_name, model) {
        this._name = _name;
        this.model = model;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
    }
    set additionalField(value) {
        this._additionalField = value;
    }
    addTableField(table, field) {
        if (!this._tableFields) {
            this._tableFields = [];
        }
        this._tableFields.push(table.getField(field));
    }
    set required(value) {
        this._required = value;
    }
    set column(value) {
        this._column = value;
    }
    set int(value) {
        this._int = value;
    }
    set aggregateFunction(fn) {
        this._aggregateFunction = fn;
    }
    get aggregateFunction() {
        return this._aggregateFunction;
    }
    set transformer(fn) {
        this._transformer = fn;
    }
    get tableFields() {
        return this._tableFields || [];
    }
    /**
     * Extract the default value for this field
     * @protected
     */
    get defaultValue() {
        const instance = new this.model.modelConstructor();
        return instance[this.name];
    }
    /**
     * Return the value for this field in a given record
     * Fallback to the default value if it exists (given on the {@link Model} class constructor or field default value)
     * Validate if it exists (if required)
     * @param data
     * @param required
     */
    getValue(data, required = this._required) {
        if (!(this.name in data) && required) {
            const defaultValue = this.defaultValue;
            if (!defaultValue) {
                throw new Error(`Field ${this.name} is required but its missing!`);
            }
            if (this._transformer) {
                return this._transformer(defaultValue, data);
            }
            return defaultValue;
        }
        if (this._transformer) {
            return this._transformer(data[this.name], data);
        }
        return data[this.name];
    }
}
exports.ModelSchemaField = ModelSchemaField;
class SchemaAutoField extends ModelSchemaField {
    constructor(name, model, fields) {
        super(name, model);
        this.fields = fields;
    }
    static fromExistingField(field, fields) {
        const returnValue = new SchemaAutoField(field.name, field.model, fields);
        Object.assign(returnValue, field);
        return returnValue;
    }
    getValue(data) {
        const values = this.fields
            .map((x) => {
            return this.model.getField(x).getValue(data, this.required);
        })
            .map((x) => (0, helpers_1.stringify)(x));
        return (0, helpers_1.stringArrayToMd5)(values);
    }
}
exports.SchemaAutoField = SchemaAutoField;
//# sourceMappingURL=ModelSchemaField.js.map