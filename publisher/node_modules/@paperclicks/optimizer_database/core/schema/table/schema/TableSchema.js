"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TableSchema = void 0;
const TableSchemaField_1 = require("./TableSchemaField");
const TableSchemaCollection_1 = require("./TableSchemaCollection");
/**
 * Database table metadata
 *
 * @export
 * @class TableSchema
 */
class TableSchema {
    constructor(tableConstructor) {
        this.tableConstructor = tableConstructor;
        this.fieldsMap = {};
        this._writeTableName = '';
        this._readTableName = '';
    }
    get baseClass() {
        const proto = Object.getPrototypeOf(this.tableConstructor);
        if (proto && proto.name && proto.name !== '')
            return proto;
        return;
    }
    get baseTableSchema() {
        const base = this.baseClass;
        if (base) {
            return TableSchemaCollection_1.AllTableSchemas.getTable(base);
        }
    }
    /**
     * Return all table fields
     *
     * @readonly
     * @type {TableSchemaField[]}
     * @memberof TableSchema
     */
    get fields() {
        var _a;
        return [
            ...(((_a = this.baseTableSchema) === null || _a === void 0 ? void 0 : _a.fields) || []).map((x) => x.withSubClassTable(this)),
            ...Object.values(this.fieldsMap),
        ];
    }
    /**
     * Set table name
     *
     * @memberof TableSchema
     */
    set writeTableName(value) {
        this._writeTableName = value;
    }
    /**
     * Table to write data to
     *
     * @readonly
     * @type {string}
     * @memberof TableSchema
     */
    get writeTableName() {
        return this._writeTableName;
    }
    set readTableName(value) {
        this._readTableName = value;
    }
    /**
     * Table to read data from (materialized table)
     *
     * @type {string}
     * @memberof TableSchema
     */
    get readTableName() {
        return this._readTableName;
    }
    /**
     * Check if this table contains a field
     *
     * @private
     * @param {string} name
     * @returns  {boolean}
     * @memberof TableSchema
     */
    hasOwnField(name) {
        return name in this.fieldsMap;
    }
    /**
     * Add a field by name
     *
     * @param {string} name
     * @memberof TableSchema
     */
    addField(name) {
        if (!this.hasOwnField(name)) {
            this.fieldsMap[name] = new TableSchemaField_1.TableSchemaField(name, this);
        }
    }
    /**
     * Get a single table field
     *
     * @param {string} name
     * @returns  {TableSchemaField}
     * @memberof TableSchema
     */
    getField(name) {
        var _a;
        const current = this.fieldsMap[name] || ((_a = this.baseTableSchema) === null || _a === void 0 ? void 0 : _a.fieldsMap[name]);
        if (!current) {
            this.fieldsMap[name] = new TableSchemaField_1.TableSchemaField(name, this);
            return this.fieldsMap[name];
        }
        return current.withSubClassTable(this);
    }
}
exports.TableSchema = TableSchema;
//# sourceMappingURL=TableSchema.js.map