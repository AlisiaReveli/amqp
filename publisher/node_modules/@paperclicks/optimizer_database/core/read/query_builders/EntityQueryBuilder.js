"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityQueryBuilder = void 0;
const Formula_1 = require("../sql/formulas/Formula");
const ReadQuery_1 = require("../sql/ReadQuery");
const ModelSchemaCollection_1 = require("../../schema/model/schema/ModelSchemaCollection");
const BaseQueryBuilder_1 = require("./BaseQueryBuilder");
const PerformanceQueryBuilder_1 = require("./PerformanceQueryBuilder");
const GetPerformanceRequest_1 = require("../request/GetPerformanceRequest");
class EntityQueryBuilder extends BaseQueryBuilder_1.BaseQueryBuilder {
    constructor(_request) {
        super();
        this._request = _request;
        /**
         * Save the inner query builders for the performance models
         *
         * @private
         * @type {Array<PerformanceQueryBuilder>}
         * @memberof EntityQueryBuilder
         */
        this._joins = [];
        /*
         * Build the inner query builders
         */
        for (const join of this.modelSchema.joinModels) {
            this._joins.push(new PerformanceQueryBuilder_1.PerformanceQueryBuilder(GetPerformanceRequest_1.GetPerformanceRequest.from(this._request, join.schema
                .modelConstructor), join, this.type));
        }
    }
    /**
     * Return the entity type
     *
     * @readonly
     * @protected
     * @type {string}
     * @memberof EntityQueryBuilder
     */
    get type() {
        const modelInstance = new this._request.model();
        return modelInstance.entityType;
    }
    /**
     * Return the ModelSchema for this entity
     *
     * @readonly
     * @protected
     * @type {ModelSchema}
     * @memberof EntityQueryBuilder
     */
    get modelSchema() {
        return ModelSchemaCollection_1.AllModelSchemas.getModel(this._request.model);
    }
    /**
     * Add a single field to the select clause of the query
     * and if requested to the where clause
     *
     * @protected
     * @param {TableSchemaField} field
     * @param {ModelSchemaField} modelField
     * @param {ReadQuery.Query} query
     * @returns  {ReadQuery.Query}
     * @memberof EntityQueryBuilder
     */
    addQueryField(field, modelField, query) {
        const alias = modelField.name;
        const select = field.name;
        query = query.select(select, alias);
        for (const condition of this._request.findConditions(alias)) {
            query = condition.updateQuery(query);
        }
        return query;
    }
    /**
     * Return the full query joined with the performance models
     *
     * @returns  {ReadQuery.Query}
     * @memberof EntityQueryBuilder
     */
    getQuery() {
        const mainQueryResults = this.getEntityQuery();
        const fieldMap = mainQueryResults.fieldMap;
        const allAggregatedFields = new Set();
        let mainQuery = mainQueryResults.query;
        for (const performanceQueryBuilder of this._joins) {
            const performanceQueries = performanceQueryBuilder.getTableQueries();
            const aggregatedFields = performanceQueryBuilder.aggregatedFields;
            for (const aggregatedField of aggregatedFields) {
                allAggregatedFields.add(aggregatedField);
            }
            for (const { query: performanceQuery, alias, } of performanceQueries) {
                const querySelectAliases = performanceQuery.selectAliases.filter((fieldAlias) => aggregatedFields.has(fieldAlias));
                for (const selectAlias of querySelectAliases) {
                    fieldMap[selectAlias] = `${alias}.${selectAlias}`;
                }
                mainQuery = mainQuery.leftJoin(performanceQuery, (w) => {
                    for (const [left, right,] of performanceQueryBuilder.joinFields) {
                        w = w.and(`${this.alias}.${left}`, '=', `${alias}.${right || left}`);
                    }
                    return w;
                }, alias);
            }
        }
        const queryWithSelects = this.selectFieldsFromQuery(mainQuery, fieldMap, allAggregatedFields);
        const whereQuery = this.addWheresToQuery(queryWithSelects);
        let finalQuery = new ReadQuery_1.ReadQuery.Query().from(whereQuery);
        for (const selectField of this._request.selectFields) {
            finalQuery = finalQuery.select(selectField);
        }
        return finalQuery;
    }
    addWheresToQuery(query) {
        for (const condition of this._request.conditions) {
            query = condition.updateQuery(query, true);
        }
        return query;
    }
    /**
     * Return the EntityTable query for this  EntityModel
     *
     * @private
     * @returns  {{
     * 		query: ReadQuery.Query;
     * 		fieldMap: Record<string, string>;
     * 	}}
     * @memberof EntityQueryBuilder
     */
    getEntityQuery() {
        const [first] = this.getTableQueries().filter((x) => x.table.tableConstructor);
        const fieldMap = {};
        for (const selectAlias of first.query.selectAliases) {
            fieldMap[selectAlias] = `${first.alias}.${selectAlias}`;
        }
        const query = new ReadQuery_1.ReadQuery.Query().from(first.query, first.alias);
        return { query, fieldMap };
    }
    /**
     * Add the applicable fields to the select clause of the query
     *
     * @private
     * @param {ReadQuery.Query} query
     * @returns  {ReadQuery.Query}
     * @memberof EntityQueryBuilder
     */
    selectFieldsFromQuery(query, fieldMap, aggregatedFields) {
        const formulas = this._request.allFields.map((x) => new Formula_1.Formula(x.alias, x.value, this._request.customFormulas));
        for (const formula of formulas) {
            query = query.select(formula.getSql(fieldMap, aggregatedFields), formula.alias);
        }
        return query;
    }
    /**
     * Return the unique set of requested fields for this query
     *
     * @readonly
     * @protected
     * @type {Set<string>}
     * @memberof EntityQueryBuilder
     */
    get fieldSet() {
        const formulas = this._request.allFields.map((x) => new Formula_1.Formula(x.alias, x.value, this._request.customFormulas));
        return new Set([
            ...formulas
                .map((x) => {
                return x.getDependencies();
            })
                .flat(),
        ]);
    }
}
exports.EntityQueryBuilder = EntityQueryBuilder;
//# sourceMappingURL=EntityQueryBuilder.js.map