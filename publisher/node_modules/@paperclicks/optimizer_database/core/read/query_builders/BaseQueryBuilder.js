"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseQueryBuilder = void 0;
const ReadQuery_1 = require("../sql/ReadQuery");
class BaseQueryBuilder {
    constructor() {
        /**
         * If this flag is set it shows that the fields have already been processed
         *
         * @private
         * @type {boolean}
         * @memberof BaseQueryBuilder
         */
        this._initialized = false;
        /**
         * Processed fields map grouped by TableSchema
         * and then grouped by TableSchemaField
         *
         * @protected
         * @type {Map<
         * 		TableSchema,
         * 		Map<TableSchemaField, Array<ModelSchemaField>>
         * 	>}
         * @memberof BaseQueryBuilder
         */
        this._tableMap = new Map();
    }
    /**
     * Return the alias for this when used as a sub-query
     *
     * @readonly
     * @protected
     * @type {string}
     * @memberof BaseQueryBuilder
     */
    get alias() {
        return this.modelSchema.modelConstructor.name
            .replace(/([a-z])([A-Z])/g, '$1_$2')
            .toLowerCase();
    }
    /**
     * Initialize the groups
     * All the requested fields will be grouped by table and then  by table fields
     *
     * @protected
     * @memberof BaseQueryBuilder
     */
    init() {
        if (!this._initialized) {
            const modelSchemaFields = this.modelSchema.fields.filter((modelSchemaField) => this.fieldSet.has(modelSchemaField.name));
            for (const schemaField of modelSchemaFields) {
                this.addField(schemaField);
            }
            this._initialized = true;
        }
    }
    /**
     * Add a field to the processed groups by finding its table fields
     * and their parent tables
     *
     * @private
     * @param {ModelSchemaField} field
     * @memberof BaseQueryBuilder
     */
    addField(field) {
        for (const tableField of field.tableFields) {
            const currentTableMap = this._tableMap.get(tableField.table) ||
                new Map();
            const currentTableFieldData = currentTableMap.get(tableField) || new Set();
            currentTableFieldData.add(field);
            currentTableMap.set(tableField, currentTableFieldData);
            this._tableMap.set(tableField.table, currentTableMap);
        }
    }
    /**
     * Build the queries for each table in the processed groups
     *
     * @returns  {Array<{
     * 		query: ReadQuery.Query;
     * 		alias: string;
     * 		table: TableSchema;
     * 	}>}
     * @memberof BaseQueryBuilder
     */
    getTableQueries() {
        this.init();
        const queries = [];
        for (const [table, fields] of this._tableMap) {
            const query = this.buildTableQuery(table, fields);
            if (query) {
                queries.push({
                    query,
                    alias: this.alias,
                    table,
                });
            }
        }
        return queries;
    }
    /**
     * Build the {@link ReadQuery.Query} object for a single table
     *
     * @protected
     * @param {TableSchema} table
     * @param {Map<TableSchemaField, Array<ModelSchemaField>>} fields
     * @returns  {(ReadQuery.Query | null)}
     * @memberof BaseQueryBuilder
     */
    buildTableQuery(table, fields) {
        let query = new ReadQuery_1.ReadQuery.Query().from(table.readTableName);
        for (const [tableField, modelFields] of fields) {
            for (const modelField of modelFields) {
                query = this.addQueryField(tableField, modelField, query);
            }
        }
        return query;
    }
}
exports.BaseQueryBuilder = BaseQueryBuilder;
//# sourceMappingURL=BaseQueryBuilder.js.map