import { ReadQuery } from '../sql/ReadQuery';
import { ModelSchema } from '../../schema/model/schema/ModelSchema';
import { ModelSchemaField } from '../../schema/model/schema/ModelSchemaField';
import { TableSchema } from '../../schema/table/schema/TableSchema';
import { TableSchemaField } from '../../schema/table/schema/TableSchemaField';
export declare abstract class BaseQueryBuilder {
    /**
     * Return the model schema to read the values from
     *
     * @readonly
     * @protected
     * @abstract
     * @type {ModelSchema}
     * @memberof BaseQueryBuilder
     */
    protected abstract get modelSchema(): ModelSchema;
    /**
     * Return the field set required in this request
     *
     * @readonly
     * @protected
     * @abstract
     * @type {Set<string>}
     * @memberof BaseQueryBuilder
     */
    protected abstract get fieldSet(): Set<string>;
    /**
     * Return the entity type
     *
     * @readonly
     * @protected
     * @abstract
     * @type {string}
     * @memberof BaseQueryBuilder
     */
    protected abstract get type(): string;
    /**
     * If this flag is set it shows that the fields have already been processed
     *
     * @private
     * @type {boolean}
     * @memberof BaseQueryBuilder
     */
    private _initialized;
    /**
     * Return the alias for this when used as a sub-query
     *
     * @readonly
     * @protected
     * @type {string}
     * @memberof BaseQueryBuilder
     */
    protected get alias(): string;
    /**
     * Processed fields map grouped by TableSchema
     * and then grouped by TableSchemaField
     *
     * @protected
     * @type {Map<
     * 		TableSchema,
     * 		Map<TableSchemaField, Array<ModelSchemaField>>
     * 	>}
     * @memberof BaseQueryBuilder
     */
    protected _tableMap: Map<TableSchema, Map<TableSchemaField, Set<ModelSchemaField>>>;
    /**
     * Initialize the groups
     * All the requested fields will be grouped by table and then  by table fields
     *
     * @protected
     * @memberof BaseQueryBuilder
     */
    protected init(): void;
    /**
     * Add a field to the processed groups by finding its table fields
     * and their parent tables
     *
     * @private
     * @param {ModelSchemaField} field
     * @memberof BaseQueryBuilder
     */
    private addField;
    /**
     * Build the queries for each table in the processed groups
     *
     * @returns  {Array<{
     * 		query: ReadQuery.Query;
     * 		alias: string;
     * 		table: TableSchema;
     * 	}>}
     * @memberof BaseQueryBuilder
     */
    getTableQueries(): Array<{
        query: ReadQuery.Query;
        alias: string;
        table: TableSchema;
    }>;
    /**
     * Build the {@link ReadQuery.Query} object for a single table
     *
     * @protected
     * @param {TableSchema} table
     * @param {Map<TableSchemaField, Array<ModelSchemaField>>} fields
     * @returns  {(ReadQuery.Query | null)}
     * @memberof BaseQueryBuilder
     */
    protected buildTableQuery(table: TableSchema, fields: Map<TableSchemaField, Set<ModelSchemaField>>): ReadQuery.Query | null;
    /**
     * Add a particular field to the select clause of the query
     * and if applicable add it to the where/having clauses
     *
     * @protected
     * @abstract
     * @param {TableSchemaField} field
     * @param {ModelSchemaField} modelField
     * @param {ReadQuery.Query} query
     * @returns  {ReadQuery.Query}
     * @memberof BaseQueryBuilder
     */
    protected abstract addQueryField(field: TableSchemaField, modelField: ModelSchemaField, query: ReadQuery.Query): ReadQuery.Query;
}
