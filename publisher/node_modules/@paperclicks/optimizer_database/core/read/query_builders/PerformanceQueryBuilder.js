"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PerformanceQueryBuilder = void 0;
const Formula_1 = require("../sql/formulas/Formula");
const ReadQuery_1 = require("../sql/ReadQuery");
const BaseQueryBuilder_1 = require("./BaseQueryBuilder");
class PerformanceQueryBuilder extends BaseQueryBuilder_1.BaseQueryBuilder {
    constructor(_request, _model, _type) {
        super();
        this._request = _request;
        this._model = _model;
        this._type = _type;
    }
    get type() {
        const modelInstance = new this.modelSchema.modelConstructor();
        return modelInstance.entityType || this._type;
    }
    get modelSchema() {
        return this._model.schema;
    }
    get fieldSet() {
        const formulas = this._request.allFields.map((x) => new Formula_1.Formula(x.alias, x.value, this._request.customFormulas));
        return new Set([
            ...formulas
                .map((x) => {
                return x.getDependencies();
            })
                .flat(),
            ...this._model.fields.map(([left, right]) => (right || left)),
        ]);
    }
    get aggregatedFields() {
        const modelSchemaFields = new Set();
        for (const table of this._tableMap.values()) {
            for (const tableFields of table.values()) {
                for (const field of tableFields) {
                    if (field.aggregateFunction) {
                        modelSchemaFields.add(field);
                    }
                }
            }
        }
        return new Set(Array.from(modelSchemaFields).map((x) => x.name));
    }
    get joinFields() {
        return this._model.fields;
    }
    /**
     * Add a particular field to the select clause of the query
     * and if applicable add it to the where/having clauses
     *
     * @protected
     * @param {TableSchemaField} field
     * @param {ModelSchemaField} modelField
     * @param {ReadQuery.Query} query
     * @returns  {ReadQuery.Query}
     * @memberof PerformanceQueryBuilder
     */
    addQueryField(field, modelField, query) {
        const alias = modelField.name;
        const tableField = field.name;
        const select = modelField.aggregateFunction
            ? `${modelField.aggregateFunction}(MAX2(${tableField}, 0))`
            : tableField;
        query = query.select(select, alias);
        if (!modelField.aggregateFunction) {
            query = query.groupBy(field.name);
        }
        for (const condition of this._request.findConditions(alias)) {
            query = condition.updateQuery(query, !!modelField.aggregateFunction);
        }
        return query;
    }
    /**
     * Return the {@link ReadQuery.Query} object for a particular table
     * Since this is the query builder for the performance models
     * if no aggregation field is used in the query return null
     *
     * @protected
     * @param {TableSchema} table
     * @param {Map<TableSchemaField, Array<ModelSchemaField>>} fields
     * @returns  {(ReadQuery.Query | null)}
     * @memberof PerformanceQueryBuilder
     */
    buildTableQuery(table, fields) {
        let hasAggregateColumns = false;
        let query = new ReadQuery_1.ReadQuery.Query().from(table.readTableName);
        for (const [tableField, modelFields] of fields) {
            if (Array.from(modelFields).some((x) => x.aggregateFunction)) {
                hasAggregateColumns = true;
            }
            for (const modelField of modelFields) {
                query = this.addQueryField(tableField, modelField, query);
            }
        }
        if (!hasAggregateColumns)
            return null;
        return query;
    }
}
exports.PerformanceQueryBuilder = PerformanceQueryBuilder;
//# sourceMappingURL=PerformanceQueryBuilder.js.map