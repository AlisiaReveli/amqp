"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReadQuery = void 0;
const sqlstring_1 = __importDefault(require("sqlstring"));
const cli_highlight_1 = __importDefault(require("cli-highlight"));
const sql_formatter_1 = require("sql-formatter");
var ReadQuery;
(function (ReadQuery) {
    function wrap(statement) {
        if (statement instanceof QueryBlock) {
            return `(${statement.toString()})`;
        }
        return escapeParameter(statement);
    }
    function isParameter(value) {
        return value.startsWith(':');
    }
    function escapeParameter(name) {
        if (isParameter(name)) {
            return name;
        }
        return name;
    }
    const WHITESPACE = ' ';
    const COMMA = ',';
    let Keywords;
    (function (Keywords) {
        Keywords["FROM"] = "from";
        Keywords["SELECT"] = "select";
        Keywords["ON"] = "on";
        Keywords["AS"] = "as";
        Keywords["AND"] = "and";
        Keywords["OR"] = "or";
        Keywords["GROUP_BY"] = "group by";
        Keywords["ORDER_BY"] = "order by";
        Keywords["JOIN"] = "join";
        Keywords["WHERE"] = "where";
        Keywords["HAVING"] = "having";
        Keywords["OFFSET"] = "offset";
        Keywords["LIMIT"] = "limit";
    })(Keywords = ReadQuery.Keywords || (ReadQuery.Keywords = {}));
    let OrderByType;
    (function (OrderByType) {
        OrderByType["ASC"] = "asc";
        OrderByType["DESC"] = "desc";
    })(OrderByType = ReadQuery.OrderByType || (ReadQuery.OrderByType = {}));
    let JoinType;
    (function (JoinType) {
        JoinType["LEFT"] = "left";
        JoinType["RIGHT"] = "right";
        JoinType["INNER"] = "inner";
        JoinType["OUTER"] = "outer";
    })(JoinType = ReadQuery.JoinType || (ReadQuery.JoinType = {}));
    class QueryBlock {
        prettyPrint() {
            console.log((0, cli_highlight_1.default)((0, sql_formatter_1.format)(this.toString(), {
                keywordCase: 'upper',
                indentStyle: 'tabularRight',
                tabulateAlias: true,
            }), {
                language: 'sql',
                ignoreIllegals: true,
            }));
        }
    }
    class SelectItem extends QueryBlock {
        constructor(formula, _alias) {
            super();
            this.formula = formula;
            this._alias = _alias;
        }
        toString() {
            const str = [this.formula];
            if (this._alias) {
                str.push(Keywords.AS, escapeParameter(this._alias));
            }
            return str.join(WHITESPACE);
        }
        get alias() {
            return this._alias;
        }
    }
    class Select extends QueryBlock {
        constructor(from, items = []) {
            super();
            this.from = from;
            this.items = items;
        }
        clone() {
            return new Select(this.from, [...this.items]);
        }
        setFrom(from) {
            return new Select(from, [...this.items]);
        }
        addSelect(formula, alias) {
            return new Select(this.from, [
                ...this.items,
                new SelectItem(formula, alias),
            ]);
        }
        get fields() {
            return this.items
                .map((x) => x.alias)
                .reduce((accumulator, item) => {
                if (item) {
                    return [...accumulator, item];
                }
                return accumulator;
            }, []);
        }
        toString() {
            if (!this.from || this.items.length === 0) {
                return '';
            }
            const selectClause = this.items
                .map((x) => x.toString())
                .join(COMMA);
            return [
                Keywords.SELECT,
                selectClause,
                Keywords.FROM,
                wrap(this.from),
            ].join(WHITESPACE);
        }
    }
    class Where extends QueryBlock {
        constructor(left, operator, right) {
            super();
            this.left = left;
            this.operator = operator;
            this.right = right;
        }
        clone() {
            const left = typeof this.left === 'string' ? this.left : this.left.clone();
            const right = typeof this.right === 'string'
                ? this.right
                : this.right.clone();
            return new Where(left, this.operator, right);
        }
        static from(arg) {
            if (typeof arg === 'string') {
                return arg;
            }
            else {
                const [_left, op, _right] = arg;
                const left = typeof _left === 'string' ? _left : Where.from(_left);
                const right = typeof _right === 'string' ? _right : Where.from(_right);
                return new Where(left, op, right);
            }
        }
        toString() {
            return [wrap(this.left), this.operator, wrap(this.right)].join(WHITESPACE);
        }
    }
    class WhereClause extends QueryBlock {
        constructor(clauses = []) {
            super();
            this.clauses = clauses;
        }
        clone() {
            return new WhereClause(this.clauses.map((x) => ({
                operator: x.operator,
                clause: x.clause.clone(),
            })));
        }
        and(left, operator, right) {
            const clause = new Where(Where.from(left), operator, Where.from(right));
            return new WhereClause([
                ...this.clauses,
                { operator: Keywords.AND, clause },
            ]);
        }
        or(left, operator, right) {
            const clause = new Where(Where.from(left), operator, Where.from(right));
            return new WhereClause([
                ...this.clauses,
                { operator: Keywords.OR, clause },
            ]);
        }
        toString() {
            if (this.clauses.length > 0) {
                const strings = [this.clauses[0].clause.toString()];
                strings.push(...this.clauses.slice(1).map((x) => {
                    return [x.operator, x.clause.toString()].join(WHITESPACE);
                }));
                return strings.join(WHITESPACE);
            }
            return '';
        }
    }
    class GroupBy extends QueryBlock {
        constructor(fields = []) {
            super();
            this.fields = fields;
        }
        clone() {
            return new GroupBy([...this.fields]);
        }
        addGroupBy(field) {
            return new GroupBy(Array.from(new Set([...this.fields, field])));
        }
        toString() {
            if (this.fields.length > 0) {
                return [
                    Keywords.GROUP_BY,
                    this.fields.map(escapeParameter).join(COMMA),
                ].join(WHITESPACE);
            }
            return '';
        }
    }
    class OrderBy extends QueryBlock {
        constructor(fields = []) {
            super();
            this.fields = fields;
        }
        clone() {
            return new OrderBy(this.fields.map((x) => {
                return [x[0], x[1]];
            }));
        }
        addOrderBy(field, direction) {
            return new OrderBy([
                ...this.fields.map((x) => {
                    return [x[0], x[1]];
                }),
                [field, direction],
            ]);
        }
        toString() {
            if (this.fields.length > 0) {
                return [
                    Keywords.ORDER_BY,
                    this.fields.map((x) => x.join(WHITESPACE)).join(COMMA),
                ].join(WHITESPACE);
            }
            return '';
        }
    }
    class Join extends QueryBlock {
        constructor(type, table, conditions, alias) {
            super();
            this.type = type;
            this.table = table;
            this.conditions = conditions;
            this.alias = alias;
        }
        /**
         * Return a new join object
         *
         * @returns  {Join}
         * @memberof Join
         */
        clone() {
            return new Join(this.type, this.table, this.conditions, this.alias);
        }
        /**
         * Return the SQL string section for the join
         *
         * @returns  {string}
         * @memberof Join
         */
        toString() {
            const returnValue = [this.type, Keywords.JOIN, wrap(this.table)];
            if (this.alias) {
                returnValue.push(Keywords.AS, this.alias);
            }
            returnValue.push(Keywords.ON, wrap(this.conditions));
            return returnValue.join(WHITESPACE);
        }
    }
    /**
     * SQL Query builder
     * Each builder method creates a new Query object
     * with the exception of the setParameter method which returns
     * the new query object and the parameter name to be used on conditions
     *
     * @export
     * @class Query
     * @extends {QueryBlock}
     */
    class Query extends QueryBlock {
        constructor() {
            super(...arguments);
            this._select = new Select();
            this._joins = [];
            this._parameters = {};
        }
        /**
         * Clone this query object (optionally overrides can be passed)
         *
         * @param {{
         * 				select?: Select;
         * 				alias?: string;
         * 				where?: WhereClause;
         * 				having?: WhereClause;
         * 				groupBy?: GroupBy;
         * 				joins?: Join[];
         * 				parameters?: Record<string, SqlType>;
         * 			}} [payload={}]
         * @returns  {Query}
         * @memberof Query
         */
        clone(payload = {}) {
            var _a, _b, _c, _d;
            const query = new Query();
            query._select = payload.select || this._select.clone();
            query._alias = payload.alias || this._alias;
            query._where = payload.where || ((_a = this._where) === null || _a === void 0 ? void 0 : _a.clone());
            query._having = payload.having || ((_b = this._having) === null || _b === void 0 ? void 0 : _b.clone());
            query._groupBy = payload.groupBy || ((_c = this._groupBy) === null || _c === void 0 ? void 0 : _c.clone());
            query._orderBy = payload.orderBy || ((_d = this._orderBy) === null || _d === void 0 ? void 0 : _d.clone());
            query._joins = payload.joins || this._joins.map((x) => x.clone());
            query._parameters = payload.parameters || { ...this._parameters };
            query._offset = payload.offset || this._offset;
            query._limit = payload.limit || this._limit;
            return query;
        }
        /**
         * Set from  for the select clause
         *
         * @param {(string | Query)} from
         * @param {string} [alias]
         * @returns  {Query}
         * @memberof Query
         */
        from(from, alias) {
            return this.clone({ select: this._select.setFrom(from), alias });
        }
        /**
         * Add a select field and its alias
         *
         * @param {string} formula
         * @param {string} [alias]
         * @returns  {Query}
         * @memberof Query
         */
        select(formula, alias) {
            return this.clone({
                select: this._select.addSelect(formula, alias),
            });
        }
        /**
         * Add a group by field
         *
         * @param {string} field
         * @returns  {Query}
         * @memberof Query
         */
        groupBy(field) {
            if (!this._groupBy) {
                return this.clone({ groupBy: new GroupBy([field]) });
            }
            return this.clone({ groupBy: this._groupBy.addGroupBy(field) });
        }
        /**
         * Add a order by field
         *
         * @param {string} field
         * @returns  {Query}
         * @memberof Query
         */
        orderBy(field, direction = OrderByType.ASC) {
            if (!this._orderBy) {
                return this.clone({
                    orderBy: new OrderBy([[field, direction]]),
                });
            }
            return this.clone({
                orderBy: this._orderBy.addOrderBy(field, direction),
            });
        }
        /**
         * The base method for all where building methods
         *
         * @private
         * @param {WhereArgs} left
         * @param {string} operator
         * @param {WhereArgs} right
         * @param {(Keywords.AND | Keywords.OR)} [type=Keywords.AND]
         * @returns  {Query}
         * @memberof Query
         */
        addWhere(left, operator, right, type = Keywords.AND) {
            const where = this._where || new WhereClause();
            if (type === 'and') {
                return this.clone({ where: where.and(left, operator, right) });
            }
            else {
                return this.clone({ where: where.or(left, operator, right) });
            }
        }
        /**
         * The base method for all having building methods
         *
         * @private
         * @param {WhereArgs} left
         * @param {string} operator
         * @param {WhereArgs} right
         * @param {(Keywords.AND | Keywords.OR)} [type=Keywords.AND]
         * @returns  {Query}
         * @memberof Query
         */
        addHaving(left, operator, right, type = Keywords.AND) {
            const having = this._having || new WhereClause();
            if (type === Keywords.AND) {
                return this.clone({
                    having: having.and(left, operator, right),
                });
            }
            else {
                return this.clone({ having: having.or(left, operator, right) });
            }
        }
        /**
         * Add an "AND" condition to the where clause
         *
         * @param {WhereArgs} left
         * @param {string} operator
         * @param {WhereArgs} right
         * @returns  {Query}
         * @memberof Query
         */
        where(left, operator, right) {
            return this.addWhere(left, operator, right, Keywords.AND);
        }
        /**
         * Add an "AND" condition to the where clause
         *
         * @param {WhereArgs} left
         * @param {string} operator
         * @param {WhereArgs} right
         * @returns  {Query}
         * @memberof Query
         */
        andWhere(left, operator, right) {
            return this.addWhere(left, operator, right, Keywords.AND);
        }
        /**
         * Add an "OR" condition to the where clause
         *
         * @param {WhereArgs} left
         * @param {string} operator
         * @param {WhereArgs} right
         * @returns  {Query}
         * @memberof Query
         */
        orWhere(left, operator, right) {
            return this.addWhere(left, operator, right, Keywords.OR);
        }
        /**
         * Add an "AND" having condition
         * If a having already exists this methods automatically adds an "AND"
         *
         * @param {WhereArgs} left
         * @param {string} operator
         * @param {WhereArgs} right
         * @returns  {Query}
         * @memberof Query
         */
        having(left, operator, right) {
            return this.addHaving(left, operator, right, Keywords.AND);
        }
        /**
         * Add an "AND" condition to the having clause
         *
         * @param {WhereArgs} left
         * @param {string} operator
         * @param {WhereArgs} right
         * @returns  {Query}
         * @memberof Query
         */
        andHaving(left, operator, right) {
            return this.addHaving(left, operator, right, Keywords.AND);
        }
        /**
         * Add an "OR" conditions to the having clause
         *
         * @param {WhereArgs} left
         * @param {string} operator
         * @param {WhereArgs} right
         * @returns  {Query}
         * @memberof Query
         */
        orHaving(left, operator, right) {
            return this.addHaving(left, operator, right, Keywords.OR);
        }
        /**
         * Base method for all joins
         *
         * @private
         * @param {JoinType} type
         * @param {(string | Query)} table
         * @param {(input: WhereClause) => WhereClause} conditions
         * @param {string} [alias]
         * @returns  {Query}
         * @memberof Query
         */
        join(type, table, conditions, alias) {
            return this.clone({
                joins: [
                    ...this._joins.map((x) => x.clone()),
                    new Join(type, table, conditions(new WhereClause()), alias),
                ],
            });
        }
        /**
         * Left join with a table or query
         * Conditions are built as a where clause (w: WhereClause) => WhereClause
         *
         * @param {(string | Query)} table
         * @param {(input: WhereClause) => WhereClause} conditions
         * @param {string} [alias]
         * @returns  {Query}
         * @memberof Query
         */
        leftJoin(table, conditions, alias) {
            return this.join(JoinType.LEFT, table, conditions, alias);
        }
        /**
         * Right join with a table or query
         * Conditions are built as a where clause (w: WhereClause) => WhereClause
         *
         * @param {(string | Query)} table
         * @param {(input: WhereClause) => WhereClause} conditions
         * @param {string} [alias]
         * @returns  {Query}
         * @memberof Query
         */
        rightJoin(table, conditions, alias) {
            return this.join(JoinType.RIGHT, table, conditions, alias);
        }
        /**
         * Inner join with a table or query
         * Conditions are built as a where clause (w: WhereClause) => WhereClause
         *
         * @param {(string | Query)} table
         * @param {(input: WhereClause) => WhereClause} conditions
         * @param {string} [alias]
         * @returns  {Query}
         * @memberof Query
         */
        innerJoin(table, conditions, alias) {
            return this.join(JoinType.INNER, table, conditions, alias);
        }
        /**
         * Outer join with a table or query
         * Conditions are built as a where clause (w: WhereClause) => WhereClause
         *
         * @param {(string | Query)} table
         * @param {(input: WhereClause) => WhereClause} conditions
         * @param {string} [alias]
         * @returns  {Query}
         * @memberof Query
         */
        outerJoin(table, conditions, alias) {
            return this.join(JoinType.OUTER, table, conditions, alias);
        }
        offset(value) {
            return this.clone({ offset: value });
        }
        limit(value) {
            return this.clone({ limit: value });
        }
        /**
         * Return a new query containing the new parameter on its parameters dict
         *
         * @param {string} key
         * @param {SqlType} value
         * @returns  {{ query: Query; parameter: string }}
         * @memberof Query
         */
        setParameter(key, value) {
            const query = this.clone({
                parameters: { ...this._parameters, [key]: value },
            });
            return { query, parameter: `:${key}` };
        }
        get selectAliases() {
            return this._select.fields;
        }
        /**
         * Generate a SQL String
         *
         * @returns  {string}
         * @memberof Query
         */
        toString() {
            const str = [this._select.toString()];
            if (this._alias) {
                str.push(Keywords.AS, this._alias);
            }
            if (this._joins.length) {
                this._joins.forEach((join) => {
                    str.push(join.toString());
                });
            }
            if (this._where) {
                str.push(Keywords.WHERE, this._where.toString());
            }
            if (this._groupBy) {
                str.push(this._groupBy.toString());
            }
            if (this._having) {
                str.push(Keywords.HAVING, this._having.toString());
            }
            if (this._orderBy) {
                str.push(this._orderBy.toString());
            }
            if (this._limit || this._limit === 0) {
                str.push(Keywords.LIMIT, String(this._limit));
            }
            if (this._offset || this._offset === 0) {
                str.push(Keywords.OFFSET, String(this._offset));
            }
            return this.replaceParameters(str.join(WHITESPACE));
        }
        /**
         * Replace parameters in a generated string by escaping them and using this._parameters
         *
         * @private
         * @param {string} str
         * @returns  {string}
         * @memberof Query
         */
        replaceParameters(str) {
            const matches = str.match(/:(\w+)/gim);
            if (matches) {
                for (const m of matches) {
                    const key = m.substring(1);
                    if (key in this._parameters) {
                        const item = this._parameters[key];
                        const escaped = Array.isArray(item)
                            ? `(${sqlstring_1.default.escape(item)})`
                            : sqlstring_1.default.escape(item);
                        str = str.replace(m, escaped);
                    }
                }
            }
            return str;
        }
    }
    ReadQuery.Query = Query;
})(ReadQuery = exports.ReadQuery || (exports.ReadQuery = {}));
//# sourceMappingURL=ReadQuery.js.map