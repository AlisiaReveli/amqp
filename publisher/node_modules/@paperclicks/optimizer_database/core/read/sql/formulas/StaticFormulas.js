"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StaticFormulas = void 0;
const mathjs = __importStar(require("mathjs"));
const staticFormulas = [
    { name: '_trSumRevenue', formula: 'tr_revenue + publisher_revenue' },
    {
        name: '_assertiveYieldRevenue',
        formula: `prebid_won_revenue + dynamicallocation_revenue + direct_revenue`,
    },
    { name: '_sumAdsenseRevenue', formula: 'ga_adsenseRevenue' },
    { name: '_sumGoal1Value', formula: 'ga_goal1Value' },
    { name: '_sumGoal2Value', formula: 'ga_goal2Value' },
    { name: '_sumGoal3Value', formula: 'ga_goal3Value' },
    { name: '_sumGoal4Value', formula: 'ga_goal4Value' },
    { name: '_sumGoal5Value', formula: 'ga_goal5Value' },
    {
        name: '_revenueSum',
        formula: '_trSumRevenue + _assertiveYieldRevenue + _sumAdsenseRevenue + _sumGoal1Value + _sumGoal2Value + _sumGoal3Value + _sumGoal4Value + _sumGoal5Value',
    },
    { name: 'ts_epc', formula: 'ts_revenue / ts_clicks' },
    { name: 'ts_cvr', formula: 'ts_conversions / ts_clicks' },
    { name: 'ctr', formula: 'ts_clicks / impressions' },
    { name: 'v_ctr', formula: 'ts_clicks / viewable_impressions' },
    { name: 'ecpm', formula: 'cost / impressions' },
    { name: 'click_loss', formula: 'tr_clicks - ts_clicks' },
    { name: 'ts_net', formula: 'ts_revenue - cost' },
    { name: 'ts_roi', formula: '((ts_revenue - cost) / cost) * 100' },
    { name: 'ts_cpa', formula: 'cost / ts_conversions' },
    { name: 'avg_cpc', formula: 'cost / ts_clicks' },
    {
        name: 'est_cost',
        formula: 'cost - today_cost + today_estimated_cost',
    },
    {
        name: 'est_net',
        formula: 'tr_revenue - (cost - today_cost + today_estimated_cost)',
    },
    {
        name: 'est_roi',
        formula: '(tr_revenue - (cost - today_cost + today_estimated_cost)) / (cost - today_cost + today_estimated_cost) * 100',
    },
    { name: 'lp_ctr', formula: 'lp_clicks / tr_clicks' },
    { name: 'tr_cvr', formula: 'tr_conversions / tr_clicks' },
    { name: 'lp_cr', formula: 'tr_conversions / lp_clicks' },
    { name: 'tr_cpa', formula: 'cost / tr_conversions' },
    { name: 'cp_lp_clicks', formula: 'cost / lp_clicks' },
    { name: 'total_trackers_revenue', formula: `_revenueSum` },
    { name: 'tr_net', formula: `_revenueSum - cost` },
    { name: 'tr_epc', formula: `_revenueSum / tr_clicks` },
    { name: 'tr_roi', formula: `(_revenueSum - cost) / cost * 100` },
    { name: 'epc', formula: `_revenueSum / ts_clicks` },
    { name: 'eps', formula: `_revenueSum / ga_sessions` },
    { name: 'epv', formula: `_revenueSum / ga_pageviews` },
    { name: 'epac', formula: `_revenueSum / ga_adsenseAdsClicks` },
];
class StaticFormulas {
    constructor(customFormulas = []) {
        this._formulasMap = [...staticFormulas, ...customFormulas].reduce((accumulator, item) => {
            accumulator[item.name] = item.formula;
            return accumulator;
        }, {});
    }
    hasKey(key) {
        return key in this._formulasMap;
    }
    expandNode(node) {
        switch (node.type) {
            case 'ConstantNode':
                return node;
            case 'ParenthesisNode':
                const innerExpanded = this.expandNode(node.content);
                return new mathjs.ParenthesisNode(innerExpanded);
            case 'SymbolNode':
                if (this.hasKey(node.name)) {
                    const parsed = mathjs.parse(this._formulasMap[node.name]);
                    return this.expandNode(parsed);
                }
                return node;
            case 'OperatorNode':
                const args = node.args.map((x) => this.expandNode(x));
                return new mathjs.OperatorNode(node.op, node.fn, args, node.implicit);
        }
        return node;
    }
}
exports.StaticFormulas = StaticFormulas;
//# sourceMappingURL=StaticFormulas.js.map