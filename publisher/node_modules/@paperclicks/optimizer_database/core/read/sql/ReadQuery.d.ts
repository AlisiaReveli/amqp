export declare namespace ReadQuery {
    export enum Keywords {
        FROM = "from",
        SELECT = "select",
        ON = "on",
        AS = "as",
        AND = "and",
        OR = "or",
        GROUP_BY = "group by",
        ORDER_BY = "order by",
        JOIN = "join",
        WHERE = "where",
        HAVING = "having",
        OFFSET = "offset",
        LIMIT = "limit"
    }
    export enum OrderByType {
        ASC = "asc",
        DESC = "desc"
    }
    export enum JoinType {
        LEFT = "left",
        RIGHT = "right",
        INNER = "inner",
        OUTER = "outer"
    }
    class QueryBlock {
        prettyPrint(): void;
    }
    class SelectItem extends QueryBlock {
        private formula;
        private _alias?;
        constructor(formula: string, _alias?: string | undefined);
        toString(): string;
        get alias(): string | undefined;
    }
    class Select extends QueryBlock {
        private from?;
        private items;
        constructor(from?: string | Query | undefined, items?: SelectItem[]);
        clone(): Select;
        setFrom(from: string | Query): Select;
        addSelect(formula: string, alias?: string): Select;
        get fields(): string[];
        toString(): string;
    }
    export type WhereCtorArgs = [WhereArgs, string, WhereArgs];
    export type WhereArgs = string | WhereCtorArgs;
    export type SqlType = string | number | boolean | null | Array<SqlType>;
    class Where extends QueryBlock {
        private left;
        private operator;
        private right;
        constructor(left: string | Where, operator: string, right: string | Where);
        clone(): Where;
        static from(arg: WhereArgs): Where | string;
        toString(): string;
    }
    class WhereClause extends QueryBlock {
        clauses: Array<{
            operator: Keywords.AND | Keywords.OR;
            clause: Where;
        }>;
        constructor(clauses?: Array<{
            operator: Keywords.AND | Keywords.OR;
            clause: Where;
        }>);
        clone(): WhereClause;
        and(left: WhereArgs, operator: string, right: WhereArgs): WhereClause;
        or(left: WhereArgs, operator: string, right: WhereArgs): WhereClause;
        toString(): string;
    }
    class GroupBy extends QueryBlock {
        private fields;
        constructor(fields?: string[]);
        clone(): GroupBy;
        addGroupBy(field: string): GroupBy;
        toString(): string;
    }
    class OrderBy extends QueryBlock {
        private fields;
        constructor(fields?: Array<[field: string, direction: OrderByType]>);
        clone(): OrderBy;
        addOrderBy(field: string, direction: OrderByType): OrderBy;
        toString(): string;
    }
    class Join extends QueryBlock {
        private type;
        private table;
        private conditions;
        private alias?;
        constructor(type: JoinType, table: string | Query, conditions: WhereClause, alias?: string | undefined);
        /**
         * Return a new join object
         *
         * @returns  {Join}
         * @memberof Join
         */
        clone(): Join;
        /**
         * Return the SQL string section for the join
         *
         * @returns  {string}
         * @memberof Join
         */
        toString(): string;
    }
    /**
     * SQL Query builder
     * Each builder method creates a new Query object
     * with the exception of the setParameter method which returns
     * the new query object and the parameter name to be used on conditions
     *
     * @export
     * @class Query
     * @extends {QueryBlock}
     */
    export class Query extends QueryBlock {
        private _select;
        private _alias?;
        private _where?;
        private _having?;
        private _groupBy?;
        private _orderBy?;
        private _joins;
        private _parameters;
        private _offset?;
        private _limit?;
        /**
         * Clone this query object (optionally overrides can be passed)
         *
         * @param {{
         * 				select?: Select;
         * 				alias?: string;
         * 				where?: WhereClause;
         * 				having?: WhereClause;
         * 				groupBy?: GroupBy;
         * 				joins?: Join[];
         * 				parameters?: Record<string, SqlType>;
         * 			}} [payload={}]
         * @returns  {Query}
         * @memberof Query
         */
        clone(payload?: {
            select?: Select;
            alias?: string;
            where?: WhereClause;
            having?: WhereClause;
            groupBy?: GroupBy;
            orderBy?: OrderBy;
            joins?: Join[];
            parameters?: Record<string, SqlType>;
            offset?: number;
            limit?: number;
        }): Query;
        /**
         * Set from  for the select clause
         *
         * @param {(string | Query)} from
         * @param {string} [alias]
         * @returns  {Query}
         * @memberof Query
         */
        from(from: string | Query, alias?: string): Query;
        /**
         * Add a select field and its alias
         *
         * @param {string} formula
         * @param {string} [alias]
         * @returns  {Query}
         * @memberof Query
         */
        select(formula: string, alias?: string): Query;
        /**
         * Add a group by field
         *
         * @param {string} field
         * @returns  {Query}
         * @memberof Query
         */
        groupBy(field: string): Query;
        /**
         * Add a order by field
         *
         * @param {string} field
         * @returns  {Query}
         * @memberof Query
         */
        orderBy(field: string, direction?: OrderByType): Query;
        /**
         * The base method for all where building methods
         *
         * @private
         * @param {WhereArgs} left
         * @param {string} operator
         * @param {WhereArgs} right
         * @param {(Keywords.AND | Keywords.OR)} [type=Keywords.AND]
         * @returns  {Query}
         * @memberof Query
         */
        private addWhere;
        /**
         * The base method for all having building methods
         *
         * @private
         * @param {WhereArgs} left
         * @param {string} operator
         * @param {WhereArgs} right
         * @param {(Keywords.AND | Keywords.OR)} [type=Keywords.AND]
         * @returns  {Query}
         * @memberof Query
         */
        private addHaving;
        /**
         * Add an "AND" condition to the where clause
         *
         * @param {WhereArgs} left
         * @param {string} operator
         * @param {WhereArgs} right
         * @returns  {Query}
         * @memberof Query
         */
        where(left: WhereArgs, operator: string, right: WhereArgs): Query;
        /**
         * Add an "AND" condition to the where clause
         *
         * @param {WhereArgs} left
         * @param {string} operator
         * @param {WhereArgs} right
         * @returns  {Query}
         * @memberof Query
         */
        andWhere(left: WhereArgs, operator: string, right: WhereArgs): Query;
        /**
         * Add an "OR" condition to the where clause
         *
         * @param {WhereArgs} left
         * @param {string} operator
         * @param {WhereArgs} right
         * @returns  {Query}
         * @memberof Query
         */
        orWhere(left: WhereArgs, operator: string, right: WhereArgs): Query;
        /**
         * Add an "AND" having condition
         * If a having already exists this methods automatically adds an "AND"
         *
         * @param {WhereArgs} left
         * @param {string} operator
         * @param {WhereArgs} right
         * @returns  {Query}
         * @memberof Query
         */
        having(left: WhereArgs, operator: string, right: WhereArgs): Query;
        /**
         * Add an "AND" condition to the having clause
         *
         * @param {WhereArgs} left
         * @param {string} operator
         * @param {WhereArgs} right
         * @returns  {Query}
         * @memberof Query
         */
        andHaving(left: WhereArgs, operator: string, right: WhereArgs): Query;
        /**
         * Add an "OR" conditions to the having clause
         *
         * @param {WhereArgs} left
         * @param {string} operator
         * @param {WhereArgs} right
         * @returns  {Query}
         * @memberof Query
         */
        orHaving(left: WhereArgs, operator: string, right: WhereArgs): Query;
        /**
         * Base method for all joins
         *
         * @private
         * @param {JoinType} type
         * @param {(string | Query)} table
         * @param {(input: WhereClause) => WhereClause} conditions
         * @param {string} [alias]
         * @returns  {Query}
         * @memberof Query
         */
        private join;
        /**
         * Left join with a table or query
         * Conditions are built as a where clause (w: WhereClause) => WhereClause
         *
         * @param {(string | Query)} table
         * @param {(input: WhereClause) => WhereClause} conditions
         * @param {string} [alias]
         * @returns  {Query}
         * @memberof Query
         */
        leftJoin(table: string | Query, conditions: (input: WhereClause) => WhereClause, alias?: string): Query;
        /**
         * Right join with a table or query
         * Conditions are built as a where clause (w: WhereClause) => WhereClause
         *
         * @param {(string | Query)} table
         * @param {(input: WhereClause) => WhereClause} conditions
         * @param {string} [alias]
         * @returns  {Query}
         * @memberof Query
         */
        rightJoin(table: string | Query, conditions: (input: WhereClause) => WhereClause, alias?: string): Query;
        /**
         * Inner join with a table or query
         * Conditions are built as a where clause (w: WhereClause) => WhereClause
         *
         * @param {(string | Query)} table
         * @param {(input: WhereClause) => WhereClause} conditions
         * @param {string} [alias]
         * @returns  {Query}
         * @memberof Query
         */
        innerJoin(table: string | Query, conditions: (input: WhereClause) => WhereClause, alias?: string): Query;
        /**
         * Outer join with a table or query
         * Conditions are built as a where clause (w: WhereClause) => WhereClause
         *
         * @param {(string | Query)} table
         * @param {(input: WhereClause) => WhereClause} conditions
         * @param {string} [alias]
         * @returns  {Query}
         * @memberof Query
         */
        outerJoin(table: string | Query, conditions: (input: WhereClause) => WhereClause, alias?: string): Query;
        offset(value: number): Query;
        limit(value: number): Query;
        /**
         * Return a new query containing the new parameter on its parameters dict
         *
         * @param {string} key
         * @param {SqlType} value
         * @returns  {{ query: Query; parameter: string }}
         * @memberof Query
         */
        setParameter(key: string, value: SqlType): {
            query: Query;
            parameter: string;
        };
        get selectAliases(): string[];
        /**
         * Generate a SQL String
         *
         * @returns  {string}
         * @memberof Query
         */
        toString(): string;
        /**
         * Replace parameters in a generated string by escaping them and using this._parameters
         *
         * @private
         * @param {string} str
         * @returns  {string}
         * @memberof Query
         */
        private replaceParameters;
    }
    export {};
}
